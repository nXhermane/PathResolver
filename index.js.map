{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iDAAoB;AACzC,aAAa,mBAAO,CAAC,mCAAa;;;;;;;;;;;ACjBrB;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,gBAAgB,mBAAO,CAAC,+BAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA,oBAAoB;;;;;;;;;;;ACzIP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;UC/Bb;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://pathresolver/webpack/universalModuleDefinition","webpack://pathresolver/./index.ts","webpack://pathresolver/./src/PathResolver.ts","webpack://pathresolver/./src/Utils.ts","webpack://pathresolver/webpack/bootstrap","webpack://pathresolver/webpack/before-startup","webpack://pathresolver/webpack/startup","webpack://pathresolver/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pathresolver\"] = factory();\n\telse\n\t\troot[\"pathresolver\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./src/PathResolver\"), exports);\n__exportStar(require(\"./src/Utils\"), exports);\n","\"use strict\";\n/**\n * Path Exemple\n * ----------\n1 -  patient.age.cm\n2 - patient.medicalCondition[1]\n3 - patient.medicalCondition[mapOrSetKey]\n4 - patient.getAgeMonth()\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathResolver = void 0;\nconst Utils_1 = require(\"./Utils\");\nclass PathResolver {\n    constructor(context) {\n        this.context = context;\n    }\n    tokenise(path) {\n        const tokens = this.splitPathToSegment(path);\n        const tokensWithInfo = [];\n        for (let i = 0; i < tokens.length; i++) {\n            const segment = tokens[i];\n            if (Utils_1.Utils.isArraySegment(segment)) {\n                const token = this.parseArrayOrMapAndSet(segment);\n                tokensWithInfo.push(token);\n            }\n            else if (Utils_1.Utils.isFunctionSegment(segment)) {\n                const token = this.parseFunction(segment);\n                tokensWithInfo.push(token);\n            }\n            else {\n                const token = { segment, type: \"property\" };\n                tokensWithInfo.push(token);\n            }\n        }\n        return tokensWithInfo;\n    }\n    splitPathToSegment(path) {\n        return path.split(\".\");\n    }\n    resolve(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokens = this.tokenise(path);\n            let counter = 0;\n            const value = yield this._resolve(tokens, this.context, counter);\n            return value;\n        });\n    }\n    _resolve(tokens, context, counter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const token = tokens[counter];\n            if (!token)\n                return context;\n            if (!context || !context.hasOwnProperty(token.segment)) {\n                throw new Error(`Invalid property or path: ${token.segment}`);\n            }\n            if (token.type === \"array\") {\n                const contextValue = context[token.segment];\n                if (!Utils_1.Utils.isArray(contextValue)) {\n                    throw new Error(`Property \"${token.segment}\" is not an array.`);\n                }\n                const value = contextValue[token === null || token === void 0 ? void 0 : token.arrayIndex];\n                return this._resolve(tokens, value, counter + 1);\n            }\n            else if (token.type === \"mapOrSet\") {\n                const contextValue = context[token.segment];\n                if (!Utils_1.Utils.isMap(contextValue) && !Utils_1.Utils.isSet(contextValue)) {\n                    throw new Error(`Property \"${token.segment}\" is not a map or set.`);\n                }\n                const value = contextValue.get(token === null || token === void 0 ? void 0 : token.mapOrSetKey);\n                return this._resolve(tokens, value, counter + 1);\n            }\n            else if (token.type === \"function\") {\n                const contextValue = context[token.segment];\n                if (!Utils_1.Utils.isFunction(contextValue)) {\n                    throw new Error(`Property \"${token.segment}\" is not a function.`);\n                }\n                if (Utils_1.Utils.isAsyncFunction(contextValue)) {\n                    const value = yield contextValue(...token === null || token === void 0 ? void 0 : token.functionArgs);\n                    return this._resolve(tokens, value, counter + 1);\n                }\n                else {\n                    const value = contextValue(...token === null || token === void 0 ? void 0 : token.functionArgs);\n                    return this._resolve(tokens, value, counter + 1);\n                }\n            }\n            else if (token.type === \"property\") {\n                const value = context[token.segment];\n                return this._resolve(tokens, value, counter + 1);\n            }\n            else {\n                throw new Error(`Invalid segment type: ${token.type}`);\n            }\n        });\n    }\n    parseArrayOrMapAndSet(segment) {\n        const match = segment.match(/(\\w+)\\[(.*?)\\]/);\n        if (match) {\n            const [, name, key] = match;\n            const isNumericKey = !isNaN(Number(key));\n            return {\n                segment: name,\n                type: isNumericKey ? \"array\" : \"mapOrSet\",\n                arrayIndex: isNumericKey ? Number(key) : undefined,\n                mapOrSetKey: isNumericKey ? undefined : key,\n            };\n        }\n        throw new Error(`Invalid segment: ${segment}`);\n    }\n    parseFunction(segment) {\n        const match = segment.match(/(\\w+)\\((.*?)\\)/);\n        if (match) {\n            const [, name, args] = match;\n            const functionArgs = args\n                ? args.split(\",\").map((arg) => {\n                    const value = arg.trim();\n                    const isNumeric = !isNaN(Number(value));\n                    return isNumeric ? Number(value) : value;\n                })\n                : [];\n            return {\n                segment: name,\n                type: \"function\",\n                functionArgs,\n            };\n        }\n        throw new Error(`Invalid function segment: ${segment}`);\n    }\n}\nexports.PathResolver = PathResolver;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Utils = void 0;\nclass Utils {\n    static isAsyncFunction(fn) {\n        return fn.constructor.name === \"AsyncFunction\";\n    }\n    static isFunctionSegment(segment) {\n        const regex = /([\\w]+)\\((([\\w]+)(,[\\w]+)*)?\\)/;\n        return regex.test(segment);\n    }\n    static isArraySegment(segment) {\n        const regex = /([\\w]+)\\[(\\w+)\\]/;\n        return regex.test(segment);\n    }\n    static isObject(value) {\n        return value instanceof Object;\n    }\n    static isFunction(value) {\n        return value instanceof Function;\n    }\n    static isArray(value) {\n        return value instanceof Array;\n    }\n    static isMap(value) {\n        return value instanceof Map;\n    }\n    static isSet(value) {\n        return value instanceof Set;\n    }\n}\nexports.Utils = Utils;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./index.ts\");\n",""],"names":[],"sourceRoot":""}